<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CREED SHOOTER</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --pink: #ff007f;
            --pink-glow: 0 0 15px rgba(255, 0, 127, 0.6);
            --dark: #050002;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--dark);
            font-family: 'Segoe UI', sans-serif;
            color: white; user-select: none; touch-action: none;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, rgba(20,0,10,0.4) 0%, rgba(5,0,2,0.9) 100%);
            pointer-events: auto;
        }
        .hidden { display: none !important; }
        h1 {
            font-size: 4rem; color: var(--pink); margin-bottom: 0.5rem;
            text-shadow: var(--pink-glow); letter-spacing: 5px; font-weight: 900;
        }
        .menu-layout {
            display: flex; flex-direction: row; align-items: center; justify-content: flex-start;
            gap: 20px; width: 95%; max-width: 1200px; padding-left: 5%;
        }
        .side-panel {
            background: rgba(255, 255, 255, 0.03); padding: 2.5rem; border-radius: 24px;
            border: 2px solid var(--pink); box-shadow: var(--pink-glow);
            width: 320px; text-align: center; backdrop-filter: blur(10px);
        }
        .preview-box {
            flex-grow: 1; height: 500px; position: relative;
            filter: drop-shadow(0 0 20px rgba(255,0,127,0.3));
        }
        button {
            background: var(--pink); color: white; border: none; padding: 15px 24px;
            font-size: 1.2rem; border-radius: 12px; cursor: pointer; margin: 12px 0;
            font-weight: bold; width: 100%; transition: 0.3s; text-transform: uppercase;
        }
        button:hover { transform: translateY(-2px); box-shadow: var(--pink-glow); }
        button:active { transform: scale(0.95); }
        button.secondary { background: #222; border: 1px solid #444; }
        button.selected { border: 2px solid white; box-shadow: 0 0 15px var(--pink); }
        .custom-color-picker {
            margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 100%; height: 50px;
            cursor: pointer; background: none; padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid white; border-radius: 10px; }
        input[type="text"] {
            background: #111; border: 1px solid var(--pink); color: white;
            padding: 15px; border-radius: 10px; margin: 10px 0; width: 100%; text-align: center;
            box-sizing: border-box; font-size: 1.1rem;
        }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .score-board {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 60px; font-size: 4rem; font-weight: 900;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 12rem; font-weight: 900; color: white; text-shadow: var(--pink-glow);
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before { content: ''; position: absolute; background: var(--pink); width: 2px; height: 30px; left: 14px; }
        #crosshair::after { content: ''; position: absolute; background: var(--pink); width: 30px; height: 2px; top: 14px; }
        #toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: var(--pink); color: white; padding: 12px 30px; border-radius: 40px;
            font-weight: bold; display: none; z-index: 100; box-shadow: var(--pink-glow);
        }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
       
        #mobile-controls {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20; display: none;
        }
        #joystick-base {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.1); border: 2px solid var(--pink);
            border-radius: 50%; pointer-events: auto;
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: var(--pink); border-radius: 50%; transform: translate(-50%, -50%);
            box-shadow: var(--pink-glow);
        }
        #fire-btn {
            position: absolute; bottom: 60px; right: 60px; width: 100px; height: 100px;
            background: rgba(255, 0, 127, 0.4); border: 4px solid var(--pink);
            border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center;
            font-weight: 900; color: white; box-shadow: var(--pink-glow);
        }
        #touch-look {
            position: absolute; top: 0; right: 0; width: 60%; height: 100%;
            pointer-events: auto;
        }
        #orientation-warning {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: var(--pink); z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            font-size: 2rem; text-align: center; padding: 20px; box-sizing: border-box;
        }
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .menu-layout { flex-direction: column; padding-left: 0; }
            .side-panel { width: 80%; padding: 1rem; }
            .preview-box { display: none; }
            .score-board { font-size: 2rem; }
            #mobile-controls { display: block; }
        }
    </style>
</head>
<body>
    <div id="orientation-warning" class="hidden">
        <h1>ROTATE YOUR PHONE</h1>
        <p>Please turn your device to landscape mode to play.</p>
    </div>

    <div id="ui-layer">
        <div id="main-menu" class="screen">
            <h1>CREED SHOOTER</h1>
            <div class="menu-layout">
                <div class="side-panel">
                    <button onclick="startQuickPlay()" style="background: linear-gradient(45deg, #ff007f, #ff5e00);">Quick Play</button>
                    <button class="secondary" onclick="initHost()">Create Match</button>
                    <button class="secondary" onclick="showScreen('lobby-join')">Join Player</button>
                    <div class="custom-color-picker">
                        <label>YOUR SKIN COLOR</label>
                        <input type="color" id="color-input" value="#ff007f" oninput="updateMyColor(this.value)">
                    </div>
                </div>
                <div class="preview-box" id="menu-canvas-container"></div>
            </div>
        </div>
        <div id="lobby-join" class="screen hidden">
            <h1>JOIN PLAYER</h1>
            <div class="side-panel">
                <input type="text" id="join-id" placeholder="ROOM ID">
                <button onclick="joinMatch()">Connect</button>
                <button class="secondary" onclick="showScreen('main-menu')">Back</button>
            </div>
        </div>
        <div id="lobby-wait" class="screen hidden">
            <h1 id="lobby-header">LOBBY</h1>
            <div class="side-panel">
                <div id="id-container">
                    <p>ROOM ID:</p>
                    <h2 id="display-id" style="color: var(--pink); margin: 10px 0; font-size: 2rem;">----</h2>
                    <button onclick="copyId()" style="width: auto; padding: 8px 20px; font-size: 0.9rem;">Copy ID</button>
                </div>
                <p id="connected-count" style="margin-top: 25px;">WAITING FOR PLAYER...</p>
                <div style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                    <p>MAP VOTE:</p>
                    <div style="display: flex; gap: 10px;">
                        <button id="vote-dark" class="secondary selected" onclick="vote('dark')">Night</button>
                        <button id="vote-light" class="secondary" onclick="vote('light')">Day</button>
                    </div>
                </div>
                <button id="start-btn" class="hidden" onclick="hostStartGame()">Start</button>
            </div>
        </div>
        <div id="result-screen" class="screen hidden">
            <h1 id="result-text">GAME OVER</h1>
            <div class="side-panel">
                <h2 id="final-score" style="font-size: 3rem; margin: 20px 0;">0 - 0</h2>
                <button onclick="location.reload()">Menu</button>
            </div>
        </div>
        <div id="hud" class="hidden">
            <div class="score-board">
                <div id="score-a" style="color: white">0</div>
                <div id="score-b" style="color: white">0</div>
            </div>
            <div id="crosshair"></div>
            <div id="countdown" class="hidden">3</div>
           
            <div id="mobile-controls">
                <div id="touch-look"></div>
                <div id="joystick-base"><div id="joystick-stick"></div></div>
                <div id="fire-btn">SHOOT</div>
            </div>
        </div>
    </div>
    <div id="toast">ID COPIED</div>
    <div id="game-container"></div>
    <script>
        const bgMusic = new Audio('https://github.com/alameen67/gameeeeeeeee/raw/refs/heads/main/1223.MP3');
        bgMusic.loop = true; bgMusic.volume = 0.08;
        const laserSound = new Audio('https://github.com/alameen67/gameeeeeeeee/raw/refs/heads/main/laser-fire.mp3');
        laserSound.volume = 0.12;
        const deathSound = new Audio('https://github.com/alameen67/gameeeeeeeee/raw/refs/heads/main/among-us-kill-sound-effect-hd_gIEZqxo.mp3');
        deathSound.volume = 0.25;
        let localStream, audioContext, analyser, dataArray, micVolume = 0;
        let scene, camera, renderer, clock, menuCharacter;
        let players = {}, collidables = [], myId, isHost = false, myTeam = 'a';
        let scores = { a: 0, b: 0 }, peer, connections = [];
        let yaw = 0, pitch = 0, canMove = false, gameState = 'menu';
        let myVote = 'dark', mapTheme = 'dark', myColor = '#ff007f';
        let viewMelee;
        const PLAYER_HEIGHT = 2.5, PLAYER_RADIUS = 0.7, ARENA_SIZE = 35;
        const keys = { KeyW: false, KeyS: false, KeyA: false, KeyD: false };
        let joystickActive = false;
        let moveVec = { x: 0, y: 0 };
        let lastTouchX = 0, lastTouchY = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let currentQuickIndex = 0;

        function checkOrientation() {
            if (!isMobile) return;
            const warning = document.getElementById('orientation-warning');
            if (window.innerHeight > window.innerWidth) {
                warning.classList.remove('hidden');
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('game-container').style.display = 'none';
            } else {
                warning.classList.add('hidden');
                document.getElementById('ui-layer').style.display = 'block';
                document.getElementById('game-container').style.display = 'block';
            }
        }

        window.onload = () => {
            checkOrientation();
            window.addEventListener('orientationchange', checkOrientation);
            window.addEventListener('resize', checkOrientation);
            initGraphics(true);
            showScreen('main-menu');
            initMobileControls();
        };

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
            gameState = (id === 'main-menu') ? 'menu' : 'lobby';
        }

        function updateMyColor(val) {
            myColor = val;
            if (menuCharacter) menuCharacter.userData.body.material.color.set(val);
        }

        function createCharacter(color) {
            const group = new THREE.Group();
            const bodyGeo = new THREE.CylinderGeometry(0.7, 0.7, 2.5, 16);
            bodyGeo.translate(0, 1.25, 0);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);
            group.userData.body = body;
            const FACE_Z = -0.71;
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyeL.position.set(0.25, 2.15, FACE_Z);
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            pupilL.position.set(0, 0, -0.09);
            eyeL.add(pupilL);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyeR.position.set(-0.25, 2.15, FACE_Z);
            const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            pupilR.position.set(0, 0, -0.09);
            eyeR.add(pupilR);
            group.add(eyeR);
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.05), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            mouth.position.set(0, 1.85, FACE_Z - 0.01);
            group.add(mouth);
            group.userData.mouth = mouth;
            const weapon = createMeleeMesh();
            weapon.position.set(0.8, 1.2, -0.5);
            weapon.rotation.x = Math.PI/2;
            group.add(weapon);
            return group;
        }

        function createMeleeMesh() {
            const group = new THREE.Group();
            const bladeGeo = new THREE.BoxGeometry(0.1, 1.2, 0.2);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2, transparent: true, opacity: 0.9 });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.6;
            group.add(blade);
            const handleGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.4);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.1;
            group.add(handle);
            return group;
        }

        function initGraphics(isMenu = false) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050002);
            scene.fog = new THREE.Fog(0x050002, 10, 80);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const container = document.getElementById('game-container');
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 7);
            scene.add(dir);
            if (isMenu) {
                camera.position.set(-2, 2.5, 8);
                camera.lookAt(1.5, 1.5, 0);
                menuCharacter = createCharacter(myColor);
                menuCharacter.position.set(1.5, 0, 0);
                scene.add(menuCharacter);
            }
            clock = new THREE.Clock();
            animate();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                checkOrientation();
            });
            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body && (gameState === 'playing' || gameState === 'countdown')) {
                    yaw -= e.movementX * 0.002;
                    pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch - e.movementY * 0.002));
                }
            });
            document.addEventListener('mousedown', () => {
                if (gameState === 'playing' && canMove) fire();
                if (gameState === 'playing' || gameState === 'countdown') document.body.requestPointerLock();
                if(audioContext && audioContext.state === 'suspended') audioContext.resume();
            });
            window.addEventListener('keydown', e => { if (gameState === 'playing') keys[e.code] = true; });
            window.addEventListener('keyup', e => keys[e.code] = false);
        }

        function initMobileControls() {
            const joyBase = document.getElementById('joystick-base');
            const joyStick = document.getElementById('joystick-stick');
            const touchLook = document.getElementById('touch-look');
            const fireBtn = document.getElementById('fire-btn');
            joyBase.addEventListener('touchstart', e => { joystickActive = true; }, {passive: false});
            window.addEventListener('touchmove', e => {
                if (!joystickActive) return;
                const touch = Array.from(e.touches).find(t => t.target === joyBase || joyBase.contains(t.target));
                if (touch) {
                    const rect = joyBase.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    let dx = touch.clientX - centerX;
                    let dy = touch.clientY - centerY;
                    const dist = Math.min(60, Math.sqrt(dx*dx + dy*dy));
                    const angle = Math.atan2(dy, dx);
                   
                    moveVec.x = (Math.cos(angle) * dist) / 60;
                    moveVec.y = (Math.sin(angle) * dist) / 60;
                   
                    joyStick.style.left = `calc(50% + ${Math.cos(angle) * dist}px)`;
                    joyStick.style.top = `calc(50% + ${Math.sin(angle) * dist}px)`;
                }
            }, {passive: false});
            window.addEventListener('touchend', () => {
                joystickActive = false;
                moveVec = { x: 0, y: 0 };
                joyStick.style.left = '50%';
                joyStick.style.top = '50%';
            });
            touchLook.addEventListener('touchstart', e => {
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });
            touchLook.addEventListener('touchmove', e => {
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouchX;
                const dy = touch.clientY - lastTouchY;
                yaw -= dx * 0.005;
                pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch - dy * 0.005));
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState === 'playing' && canMove) fire();
                if (audioContext && audioContext.state === 'suspended') audioContext.resume();
                if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
            });
        }

        function startQuickPlay() {
            startMusic();
            document.getElementById('lobby-header').innerText = "SEARCHING...";
            document.getElementById('id-container').classList.add('hidden');
            showScreen('lobby-wait');

            if(peer) peer.destroy();
            peer = new Peer();

            peer.on('open', (id) => {
                myId = id;
                currentQuickIndex = 0;
                tryJoinNextQuickLobby();
            });
        }

        function tryJoinNextQuickLobby() {
            const lobbyId = 'CREED-QUICK-' + currentQuickIndex;
            const conn = peer.connect(lobbyId);

            let foundHost = false;
            const timeout = setTimeout(() => {
                if (!foundHost) {
                    conn.close();
                    if (currentQuickIndex === 0) {
                        createQuickHost(lobbyId);
                    } else {
                        currentQuickIndex++;
                        tryJoinNextQuickLobby();
                    }
                }
            }, 1500);

            conn.on('open', () => {
                foundHost = true;
                clearTimeout(timeout);
                myTeam = 'b';
                connections.push(conn);
                conn.on('data', data => handleIncomingData(data, conn));
                document.getElementById('connected-count').innerText = "JOINING GAME...";
            });

            conn.on('close', () => {
                if (!foundHost) {
                    currentQuickIndex++;
                    tryJoinNextQuickLobby();
                }
            });
        }

        function createQuickHost(lobbyId) {
            if(peer) peer.destroy();
            isHost = true; myTeam = 'a';
            peer = new Peer(lobbyId);
            peer.on('open', id => {
                myId = id;
                document.getElementById('lobby-header').innerText = "QUICK LOBBY " + currentQuickIndex;
                document.getElementById('connected-count').innerText = "WAITING FOR OPPONENT...";
            });
            peer.on('connection', conn => {
                connections.push(conn);
                conn.on('data', data => handleIncomingData(data, conn));
                setTimeout(() => hostStartGame(), 1000);
            });
        }

        function initHost() {
            startMusic();
            isHost = true; myTeam = 'a';
            document.getElementById('id-container').classList.remove('hidden');
            const rid = 'CREED-' + Math.floor(Math.random() * 9000 + 1000);
            peer = new Peer(rid);
            peer.on('open', id => { myId = id; document.getElementById('display-id').innerText = id; showScreen('lobby-wait'); });
            peer.on('connection', conn => {
                connections.push(conn);
                conn.on('data', data => handleIncomingData(data, conn));
                document.getElementById('connected-count').innerText = "OP READY";
                document.getElementById('start-btn').classList.remove('hidden');
            });
        }

        function joinMatch() {
            startMusic();
            const id = document.getElementById('join-id').value.toUpperCase().trim();
            if (!id) return;
            myTeam = 'b';
            peer = new Peer();
            peer.on('open', (id_gen) => {
                myId = id_gen;
                const conn = peer.connect(id);
                connections.push(conn);
                conn.on('data', data => handleIncomingData(data, conn));
                showScreen('lobby-wait');
                document.getElementById('display-id').innerText = id;
            });
        }

        function handleIncomingData(data, conn) {
            if (data.type === 'start') setupMatch(data);
            if (data.type === 'update') {
                const p = players[data.id];
                if (p && !p.isLocal) {
                    p.mesh.position.set(data.pos.x, 0, data.pos.z);
                    p.mesh.rotation.y = data.yaw;
                    p.mesh.visible = true;
                }
            }
            if (data.type === 'shot') { renderLaser(data.from, data.to, data.color); playSound(laserSound); }
            if (data.type === 'hit') { playSound(deathSound); handleScore(data.killerTeam); }
        }

        function vote(theme) {
            myVote = theme;
            document.getElementById('vote-dark').classList.remove('selected');
            document.getElementById('vote-light').classList.remove('selected');
            document.getElementById('vote-' + theme).classList.add('selected');
            if (!isHost && connections[0]) connections[0].send({ type: 'vote', theme });
        }

        function hostStartGame() {
            if(!connections[0]) return;
            const matchData = {
                type: 'start', theme: myVote,
                players: [{id: myId, team: 'a', color: myColor}, {id: connections[0].peer, team: 'b', color: '#ffffff'}]
            };
            connections[0].send(matchData);
            setupMatch(matchData);
        }

        function setupMatch(data) {
            gameState = 'countdown';
            mapTheme = data.theme;
            showScreen('hud');
            document.getElementById('hud').classList.remove('hidden');
            const playerA = data.players.find(p => p.team === 'a');
            const playerB = data.players.find(p => p.team === 'b');
            document.getElementById('score-a').style.color = playerA.color;
            document.getElementById('score-b').style.color = playerB.color;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(mapTheme === 'light' ? 0xaaaaaa : 0x050002);
            scene.fog = new THREE.Fog(scene.background, 20, 100);
            scene.add(new THREE.AmbientLight(0xffffff, mapTheme === 'light' ? 0.9 : 0.4));
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            scene.add(new THREE.GridHelper(100, 50, 0x444444, 0x222222));
            collidables = [];
            const boxGeo = new THREE.BoxGeometry(5, 12, 5);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [[15, 6, 15], [-15, 6, -15], [15, 6, -15], [-15, 6, 15], [0, 6, 22], [0, 6, -22], [0, 6, 0]].forEach(p => {
                const m = new THREE.Mesh(boxGeo, wallMat);
                m.position.set(...p);
                scene.add(m);
                collidables.push(m);
            });
            viewMelee = createMeleeMesh();
            viewMelee.scale.set(0.5, 0.5, 0.5);
            scene.add(viewMelee);
            data.players.forEach(p => {
                if (p.id === myId) { players[p.id] = { team: p.team, isLocal: true, color: p.color }; }
                else {
                    const char = createCharacter(p.color);
                    char.position.set(0, -10, 0);
                    scene.add(char);
                    players[p.id] = { team: p.team, isLocal: false, mesh: char, color: p.color };
                }
            });
            startRound();
        }

        function startRound() {
            canMove = false;
            const spawnX = myTeam === 'a' ? -30 : 30;
            yaw = myTeam === 'a' ? -Math.PI / 2 : Math.PI / 2;
            pitch = 0; camera.position.set(spawnX, PLAYER_HEIGHT, 0);
            let count = 3;
            const el = document.getElementById('countdown');
            el.innerText = count; el.classList.remove('hidden');
            const timer = setInterval(() => {
                count--;
                if(count > 0) el.innerText = count;
                else if(count === 0) { el.innerText = "START"; canMove = true; gameState = 'playing'; }
                else { el.classList.add('hidden'); clearInterval(timer); }
            }, 1000);
        }

        function fire() {
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const enemyId = Object.keys(players).find(id => !players[id].isLocal);
            const enemy = players[enemyId];
            if(!enemy || !enemy.mesh) return;
            const intersects = ray.intersectObjects([...collidables, ...enemy.mesh.children]);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const from = { x: camera.position.x, y: camera.position.y - 0.2, z: camera.position.z };
                const to = { x: hit.point.x, y: hit.point.y, z: hit.point.z };
                renderLaser(from, to, myColor);
                connections.forEach(c => c.send({ type: 'shot', from, to, color: myColor }));
                let hitEnemy = false;
                enemy.mesh.traverse(c => { if(c === hit.object) hitEnemy = true; });
                if (hitEnemy) {
                    playSound(deathSound);
                    connections.forEach(c => c.send({ type: 'hit', killerTeam: myTeam }));
                    handleScore(myTeam);
                }
            }
        }

        function renderLaser(from, to, color) {
            const mat = new THREE.LineBasicMaterial({ color: varColorToHex(color) });
            const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(from.x, from.y, from.z), new THREE.Vector3(to.x, to.y, to.z)]);
            const line = new THREE.Line(geo, mat);
            scene.add(line); setTimeout(() => scene.remove(line), 50);
        }

        function varColorToHex(c) { return parseInt(c.replace('#', '0x')); }

        function handleScore(t) {
            scores[t]++;
            document.getElementById('score-a').innerText = scores.a;
            document.getElementById('score-b').innerText = scores.b;
            if (scores[t] >= 5) {
                gameState = 'ended';
                document.getElementById('result-text').innerText = (t === myTeam ? "WINNER" : "LOSER");
                document.getElementById('final-score').innerText = `${scores.a} - ${scores.b}`;
                showScreen('result-screen');
            } else startRound();
        }

        function checkCollision(pos) {
            if (Math.abs(pos.x) > ARENA_SIZE || Math.abs(pos.z) > ARENA_SIZE) return true;
            for (let obj of collidables) {
                const b = new THREE.Box3().setFromObject(obj);
                const cx = Math.max(b.min.x, Math.min(pos.x, b.max.x));
                const cz = Math.max(b.min.z, Math.min(pos.z, b.max.z));
                const d2 = (pos.x - cx)**2 + (pos.z - cz)**2;
                if (d2 < PLAYER_RADIUS**2) return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = Date.now() * 0.002;
            if (gameState === 'menu' && menuCharacter) {
                menuCharacter.rotation.y += dt * 0.5;
                menuCharacter.position.y = Math.sin(time) * 0.15;
            }
            if (gameState === 'playing' && canMove) {
                const move = new THREE.Vector3();
                if (keys.KeyW) move.z -= 1; if (keys.KeyS) move.z += 1;
                if (keys.KeyA) move.x -= 1; if (keys.KeyD) move.x += 1;
                if (joystickActive) {
                    move.z += moveVec.y;
                    move.x += moveVec.x;
                }
                if (move.length() > 0) {
                    move.normalize().multiplyScalar(15 * dt).applyEuler(new THREE.Euler(0, yaw, 0));
                    const nx = camera.position.clone(); nx.x += move.x;
                    if (!checkCollision(nx)) camera.position.x = nx.x;
                    const nz = camera.position.clone(); nz.z += move.z;
                    if (!checkCollision(nz)) camera.position.z = nz.z;
                }
            }
            if (gameState === 'playing' || gameState === 'countdown') {
                camera.position.y = PLAYER_HEIGHT;
                camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
                if (viewMelee) {
                    const bobbing = Math.sin(time * 2) * 0.02;
                    viewMelee.position.copy(camera.position);
                    const offset = new THREE.Vector3(0.5, -0.4 + bobbing, -0.8);
                    offset.applyQuaternion(camera.quaternion);
                    viewMelee.position.add(offset);
                    viewMelee.quaternion.copy(camera.quaternion);
                    viewMelee.rotateX(Math.PI/2);
                }
                if (clock.elapsedTime % 0.033 < 0.016) {
                    connections.forEach(c => c.send({
                        type: 'update', id: myId, pos: {x: camera.position.x, z: camera.position.z},
                        yaw: yaw, vol: micVolume
                    }));
                }
            }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function copyId() {
            const t = document.getElementById('display-id').innerText;
            const el = document.createElement('textarea'); el.value = t; document.body.appendChild(el);
            el.select(); document.execCommand('copy'); document.body.removeChild(el);
            const toast = document.getElementById('toast'); toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', 2000);
        }
        function startMusic() { bgMusic.play().catch(() => {}); }
        function playSound(sound) { const clone = sound.cloneNode(); clone.volume = sound.volume; clone.play().catch(() => {}); }
    </script>
</body>
</html>